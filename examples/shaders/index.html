<!DOCTYPE html>
<html>

<head>
    <title>melonJS - shader test</title>
    <link rel="stylesheet" type="text/css" media="screen" href="index.css">
    <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">

    <script id="player-fragment-shader" type="x-shader/x-fragment">
     // Set the precision for data types used in this shader
     precision highp float;
     precision highp int;

     // Default THREE.js uniforms available to both fragment and vertex shader
     uniform mat4 modelMatrix;

     // Example varyings passed from the vertex shader
     varying vec3 vPosition;
     varying vec3 vNormal;

     void main() {
       // TODO: These should be injected
       vec3 lightPosition = vec3(0, 0, 0.25);
       vec3 color = vec3(1, 0.5, 0);

       vec3 worldPosition = ( modelMatrix * vec4( vPosition, 1.0 )).xyz;

       // Calculate the normal including the model rotation and scale
       vec3 worldNormal = normalize( vec3( modelMatrix * vec4( vNormal, 0.0 ) ) );

       vec3 lightVector = normalize( lightPosition - worldPosition );

       // An example simple lighting effect, taking the dot product of the normal
       // (which way this pixel is pointing) and a user generated light position
       float brightness = dot( worldNormal, lightVector );

       // Fragment shaders set the gl_FragColor, which is a vector4 of
       // ( red, green, blue, alpha ).
       gl_FragColor = vec4( color * brightness, 1.0 );

     }
    </script>

    <script id="player-vertex-shader" type="x-shader/x-vertex">
     // Set the precision for data types used in this shader
     precision highp float;
     precision highp int;

     // Default THREE.js uniforms available to both fragment and vertex shader
     uniform mat4 modelViewMatrix;
     uniform mat4 projectionMatrix;

     // Default attributes provided by THREE.js. Attributes are only available in the
     // vertex shader. You can pass them to the fragment shader using varyings
     attribute vec3 position;
     attribute vec3 normal;

     // Examples of variables passed from vertex to fragment shader
     varying vec3 vPosition;
     varying vec3 vNormal;

     void main() {
       // To pass variables to the fragment shader, you assign them here in the
       // main function. Traditionally you name the varying with vAttributeName
       vNormal = normal;
       vPosition = position;

       // This sets the position of the vertex in 3d space. The correct math is
       // provided below to take into account camera and object data.
       gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
     }
    </script>
</head>

<body>
    <!-- Canvas placeholder -->
    <div id="screen"></div>

    <!-- melonJS Library -->
    <script type="text/javascript" src="../../build/melonjs.js"></script>

    <!-- Plugin(s) -->
    <script type="text/javascript" src="../../plugins/debug/debugPanel.js"></script>

    <!-- Game Scripts -->
    <script type="text/javascript" src="js/game.js"></script>
    <script type="text/javascript" src="js/resources.js"></script>

    <script type="text/javascript" src="js/entities/entities.js"></script>

    <script type="text/javascript" src="js/screens/play.js"></script>

    <!-- Bootstrap -->
    <script type="text/javascript">
        me.device.onReady(function onReady() {
            game.onload();
        });
    </script>
</body>

</html>
